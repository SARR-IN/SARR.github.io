<html>

<head>

</head>

<style>

@function gray($color){
  @return rgb($color, $color, $color);
}

$shadow: rgba(0, 0, 0, 0.12) 0px 1px 6px, rgba(0, 0, 0, 0.12) 0px 1px 4px;
$cardShadow: rgba(50, 50, 93, 0.25) 0px 50px 100px -20px, rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;

$youtubeColor: rgb(198, 40, 40);

@keyframes fadeInAndExpand {
  from {
    opacity: 0;
    transform: scale(0.25);
  }

  50% {
    opacity: 0;
  }

  to {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes fadeInFromLeft {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }

  50% {
    opacity: 0;
  }

  to {
    opacity: 1;
    transform: translateX(0px);
  }
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }

  50% {
    transform: rotate(720deg);
  }

  to {
    transform: rotate(1440deg);
  }
}

.spin-animation {
  animation: spin 2s ease-in-out infinite;  
}

html {  
  &::-webkit-scrollbar-track {
    background-color: gray(30);
  }

  &::-webkit-scrollbar {
    height: 4px;
    width: 4px;
  }

  &::-webkit-scrollbar-thumb {
    background-color: rgba(white, 0.25);
    border-radius: 10px;
  }
}

body{
  background-color: gray(30);
  margin: 0px;
  padding: 0px;
  
  input, h1, a {
    color: gray(90);
    font-family: 'Rubik', sans-serif;
    font-weight: 400;
    margin: 0px;
    padding: 0px;
  }
}

#app {
  overflow: hidden;
  
  #app-background {
    height: 100vh;
    left: 0px;
    opacity: 0.4;
    position: fixed;
    top: 0px;
    width: 100vw;
    z-index: 1;
        
    &.searching {
      #app-background-image {
        transform: scale(1.25);
      }
      
      #app-background-image-filter {
        opacity: 1; 
      }
    }
    
    #app-background-image,
    #app-background-image-filter {
      height: 100%;
      width: 100%;
    }
    
    #app-background-image {
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
      position: relative;
      transition: transform 250ms;
      z-index: 1;
    }
    
    #app-background-image-filter {
      background-color: rgba(white, 0.1);
      backdrop-filter: blur(6px);
      left: 0px;
      opacity: 0;
      position: absolute;
      top: 0px;
      transition: opacity 250ms;
      z-index: 2;
    }
  }
  
  #search-bar-aligner {
    align-items: center;
    display: flex;
    justify-content: center;
    height: 100%;
    pointer-events: none;
    position: fixed;
    transition: height 250ms;
    width: 100%;
    z-index: 3;
    
    &.focused,
    &.querying,
    &.searching {
      #search-bar-wrapper {      
        #search-bar {
          #search-bar-logo {
            &:after {
              background-color: rgba(white, 0.25);
              height: 20px;
              right: 0px;
              width: 1px;
            }
          }

          #search-bar-input {
            width: 100%; 

            &::placeholder {
              color: rgba(white, 0.25);
            }
          }
        }
      }
    }
      
    &.searching {
      height: 100px;
    }
    
    #search-bar-wrapper {
      align-items: center;
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin: 10px;
      width: 500px;
      
      #search-bar {
        align-items: center;
        backdrop-filter: blur(5px);
        background-color: rgba(white, 0.1);
        border-radius: 6px;
        box-shadow: $shadow;
        display: flex;
        gap: 10px;
        justify-content: center;
        padding: 10px;
        pointer-events: all;
        position: relative;
        width: calc(100% - 20px);
        
        #search-bar-clicker {
          border-radius: 6px;
          cursor: pointer;
          height: 100%;
          left: 0px;
          position: absolute;
          top: 0px;
          width: 100%;
          z-index: 2;
        }
        
        #search-bar-logo {
          color: white;
          flex-shrink: 0;
          font-size: 0.9em;        
          height: 20px;
          line-height: 20px;
          padding: 5px;
          padding-right: 10px;
          position: relative;
          text-align: center;
          width: 14px;
          
          &:after {
            background-color: white;
            border-radius: 3px;
            content: "";            
            height: 3px;
            position: absolute;
            right: -2px;
            top: 50%;
            transform: translateY(-50%);
            transition: height 250ms, width 250ms, right 250ms, background-color 250ms;
            width: 3px;
          }
        }
        
        #search-bar-input {
          background-color: transparent;
          border: none;
          color: white;
          font-size: 1em;
          height: 20px;
          outline: none;
          padding: 10px 0px;
          text-align: left;
          transition: width 250ms;
          width: 54px;

          &::placeholder {
            color: white;
          }
        }
        
        #search-bar-reset-button {
          background-color: transparent;
          border: none;
          border-radius: 3px;
          cursor: pointer;
          flex-shrink: 0;
          height: 30px;
          outline: none;
          padding: 5px;
          position: relative;
          width: 30px;
          z-index: 3;
          
          &:hover,
          &:focus {
            background-color: rgba(white, 0.1);
          }
          
          i {
            color: white;
          }
        }
      }
      
      #search-bar-sass {
        display: flex;
        gap: 5px;
        padding: 0px 10px;
        pointer-events: all;
        width: calc(100% - 20px);
        
        #search-bar-sass-icon {
          align-items: center;
          display: flex;
          height: 18px;
          justify-content: center;
          width: 18px;
          
          &.emoji {            
            &.typing {
              i {
                animation-duration: 150ms;
              }
            }
            
            i {
              animation: fadeInAndExpand 250ms ease-in;
              font-size: 1em;
            }
          }
          
          i {
            color: white;
            font-size: 0.75em;
            height: 18px;
            line-height: 18px;
            text-align: center;
            width: 18px;
          }
        }
        
        #search-bar-sass-statement {
          animation: fadeInFromLeft 250ms ease-in;
          color: white;
          font-size: 0.8em;
          height: 18px;
          line-height: 18px;
        }
      }
    }
  }
  
  #search-results-wrapper {
    margin: auto;
    margin-top: 130px;
    max-width: 1000px;
    position: relative;
    z-index: 2;
    
    #youtube-links {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 0px 10px;
      pointer-events: all;
      
      .youtube-link {
        align-items: center;
        border-radius: 3px;
        display: flex;
        gap: 5px;
        padding: 5px 10px;
        text-decoration: none;
        white-space: nowrap;
        
        &:hover,
        &:focus {
          backdrop-filter: blur(5px);
          background-color: rgba(white, 0.1);
        }

        i, h1 {
          height: 20px;
          line-height: 20px;
        }

        i {
          color: $youtubeColor;
          font-size: 1em;
        }

        h1 {      
          color: white;
          font-size: 0.9em;
        }
      }
    }
    
    #search-results {
      display: grid;
      gap: 10px;
      grid-auto-rows: 20px;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      padding: 10px;
      padding-bottom: 50px;

      .search-result {
        background-color: gray(30);
        border-radius: 10px;
        box-shadow: $cardShadow;
        opacity: 0;
        overflow: hidden;
        position: relative;
        transform: translateY(20px);
        transition: opacity 250ms, transform 250ms;

        &.visible {
          opacity: 1;
          transform: translateY(0px);
        }

        &.loaded {
          &:hover {
            .search-result-background {
              opacity: 1;
              transform: scale(1.1);
            }
          }

          .search-result-background {
            filter: blur(0px);
            transform: scale(1);
          }

          .search-result-info-wrapper {
            display: flex; 
          }
        }

        .search-result-background {
          background-position: center;
          background-repeat: no-repeat;
          background-size: cover;
          border-radius: 10px;
          cursor: pointer;
          display: block;
          filter: blur(3px);
          height: 100%;
          opacity: 0.8;
          transform: scale(1.25);
          transition: opacity 250ms, transform 250ms, backgroundImage 250ms, filter 250ms;
          width: 100%;
        }

        .search-result-info-wrapper {
          align-items: flex-end;
          background: linear-gradient(to top, rgba(black, 0.4), transparent);
          border-radius: 10px;
          display: none;
          height: 100%;
          left: 0px;
          overflow: hidden;
          pointer-events: none;
          position: absolute; 
          top: 0px;
          width: 100%;
          z-index: 2;

          .search-result-info {
            display: flex;
            margin: 10px;
            width: calc(100% - 20px);

            .search-result-creator {
              border-radius: 3px;
              color: white;
              font-size: 0.9em;   
              overflow: hidden;
              padding: 5px 10px;
              pointer-events: all;
              text-decoration: none;
              text-overflow: ellipsis;
              white-space: nowrap;            

              &:hover {
                backdrop-filter: blur(5px);
                background-color: rgba(white, 0.1);
              }
            }
          }
        }
      }
    }
  }
}

@media(max-width: 1000px) {
  #app {
    #search-results-wrapper {
      #search-results {
        grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
      }
    }
  }
}

@media(max-width: 800px) {
  #app {
    #search-results-wrapper {
      #search-results {
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      }
    }
  }
}

@media(max-width: 500px) {
  #app {
    #search-results-wrapper {
      #search-results {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }
    }
  }
}
</style>
<body>

<div id="root"></div>


</body>

<script>
enum Icon {
  EmojiAstonished = "fa-light fa-face-astonished",
  EmojiAwesome = "fa-light fa-face-awesome",
  EmojiConfounded = "fa-light fa-face-confounded",
  EmojiCowboyHat = "fa-light fa-face-cowboy-hat",
  EmojiDisguise = "fa-light fa-face-disguise",
  EmojiDizzy = "fa-light fa-face-dizzy",
  EmojiElated = "fa-light fa-face-laugh-beam",
  EmojiGiggle = "fa-light fa-face-beam-hand-over-mouth",
  EmojiLaugh = "fa-light fa-face-laugh-squint",
  EmojiTired = "fa-light fa-face-tired",
  EmojiWink = "fa-light fa-face-grin-wink",
  Loading = "fa-regular fa-spinner-third",
  Search = "fa-regular fa-magnifying-glass"
}

enum Icon {
  Loading = "fa-regular fa-spinner-third",
  Search = "fa-regular fa-magnifying-glass"
}

enum Interaction {
  CorrectQuery = "Correct Query",
  Duplicate = "Duplicate",
  Initiated = "Initiated",
  Leaving = "Leaving",
  Returning = "Returning",
  Typing = "Typing",
  Unknown = "Unknown"
}

enum RequestStatus {
  Error = "Error",
  Idle = "Idle",
  Loading = "Loading",
  Success = "Success"
}

type UnsplashPhotoCollectionID = "animals" | "architecture" | "coffee" | "food" | "nature";

interface IUnsplashPhotoUrls {
  full: string;
  regular: string;
  small: string;
  thumbnail: string;
}

interface IUnsplashCreator {
  name: string;
  link: string;
  photo: string;
}

interface IUnsplashPhoto {
  color: string;
  creator: IUnsplashCreator;
  id: string;
  urls: IUnsplashPhotoUrls;
}

interface INumberUtility {
  random: (min: number, max: number) => number;
}

const NumberUtility: INumberUtility = {
  random: (min: number, max: number): number => {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
}

interface IInteractionUtility {
  determineSass: (state: IAppState) => ISearchBarSass;
  getRandomEmoji: (emojis: Icon[]) => Icon;
  getRandomStatement: (statements: string[]) => string;
}

const InteractionUtility: IInteractionUtility = {
  determineSass: (state: IAppState): string => {
    let statement: string = InteractionUtility.getRandomStatement([
      "Welcome! Please click on the search bar.",
      "Good day to you. Please click above to begin.",
      "Hello. Please click on me to continue."
    ]);
        
    let emoji: Icon = Icon.Search;
        
    if(state.status === RequestStatus.Loading) {
      statement = InteractionUtility.getRandomStatement([
        "Searching across the universe.",
        "Scanning every image ever.",
        "Finding your precious results.",
        "Boop beep bop boop."
      ]);
      
      emoji = Icon.Loading;
    } else if(state.interaction === Interaction.Typing) {
      if(state.query.trim() === "") {
        statement = InteractionUtility.getRandomStatement([
          `You can't search "nothing", you silly goose.`,
          `That, my friends, is what we call an "empty string".`,
          "Am bored. Pls send more letters."
        ]);
        
        emoji = Icon.EmojiDizzy;
      } else {      
        statement = InteractionUtility.getRandomStatement([
          "Great work lol.",
          "Those are some good letters.",
          "Hit enter to search.",
          "Are you sure?",
          "Is that all?"
        ]);

        emoji = InteractionUtility.getRandomEmoji([Icon.EmojiDisguise, Icon.EmojiGiggle, Icon.EmojiLaugh, Icon.EmojiWink]);
      }
    } else if (state.interaction === Interaction.Leaving) {
      statement = InteractionUtility.getRandomStatement([
        "Not good enough for ya, eh?",
        "Sayonara!",
        "Not even so much as a goodbye?",
        "Fine, cya later.",
        "See if I care!"
      ]);
      
      emoji = Icon.EmojiConfounded;
    } else if (state.interaction === Interaction.Returning) {
      statement = InteractionUtility.getRandomStatement([
        "Hooray, you're back!",
        "Please don't leave me again.",
        "It's searchin' time!"
      ]);
      
      emoji = InteractionUtility.getRandomEmoji([Icon.EmojiElated, Icon.EmojiCowboyHat]);
    } else if (state.interaction === Interaction.CorrectQuery) {
      statement = InteractionUtility.getRandomStatement([
        "Oh wow. We actually have results for that. Here you go.",
        "Well, well, well. Somebody must've been here before. Enjoy.",
        "Get that on your first try, did you? Doubt it."
      ]);
      
      emoji = Icon.EmojiAstonished;
    } else if (state.interaction === Interaction.Duplicate) {
      statement = InteractionUtility.getRandomStatement([
        "Yeah, you just searched that. Try something else.",
        "Be original please. I just searched that.",
        "C'mon now. Don't make me search that again."
      ]);
      
      emoji = InteractionUtility.getRandomEmoji([Icon.EmojiConfounded, Icon.EmojiTired]);
    } else if(state.interaction === Interaction.Initiated) {  
      if(state.searching) {
        statement = InteractionUtility.getRandomStatement([
          `Great search. Here's some ${state.collectionID} as a reward.`,
          `Hmm, haven't heard of that. Have some ${state.collectionID} instead.`,
          `Search poorly worded. Returning some ${state.collectionID} instead.`
        ]);
      } else {      
        statement = InteractionUtility.getRandomStatement([
          "Good job! Now start typing.",
          "Wow, you did it. Step 1 complete."
        ]);
      }
      
      emoji = InteractionUtility.getRandomEmoji([Icon.EmojiAwesome, Icon.EmojiElated]);
    }
      
    return {
      emoji,
      statement
    }
  },
  getRandomEmoji: (emojis: Icon[]): Icon => {
    const rand: number = NumberUtility.random(0, emojis.length - 1);
    
    return emojis[rand];
  },
  getRandomStatement: (statements: string[]): string => {
    const rand: number = NumberUtility.random(0, statements.length - 1);
    
    return statements[rand];
  }
}

const YouTubeLinks: React.FC = () => {
  const link: string = "https://www.youtube.com/watch?v=d5bZfz0ohRE&list=PLD9xos4mnoHROPklJMCUfKREJmRwXjqr2";
  
  interface YTLinkProps {
    label: string;
    url: string;
  }
  
  const YTLink: React.FC<YTLinkProps> = (props: YTLinkProps) => {
    return (   
      <a className="youtube-link" href={props.url} target="_blank">
        <i className="fa-brands fa-youtube" />
        <h1>{props.label}</h1>
      </a>
    );
  }
  
  return (
    <div id="youtube-links">      
      <YTLink label="Tutorial" url={link} />
    </div>
  );
}

interface ISearchBarSass {
  emoji: Icon;
  statement: string;
}

const defaultSass = (): ISearchBarSass => ({
  emoji: null, 
  statement: ""
});

const SearchBarSass: React.FC = () => {
  const { state } = React.useContext<IAppContext>(AppContext);
  
  const [sass, setSassTo] = React.useState<ISearchBarSass>(defaultSass());
    
  React.useEffect(() => {
    setSassTo(InteractionUtility.determineSass(state));
  }, [state]);
  
  const getIconWrapperClasses = (): string => {
    const emoji: boolean = (
      state.interaction !== Interaction.Unknown &&
      state.status !== RequestStatus.Loading
    );
    
    const typing: boolean = state.interaction === Interaction.Typing;
    
    return classNames({ emoji, typing });
  }
  
  const getIconClasses = (): string => {
    return classNames(
      sass.emoji, {
      "spin-animation": state.status === RequestStatus.Loading  
    });
  }
  
  return (
    <div id="search-bar-sass">
      <div id="search-bar-sass-icon" className={getIconWrapperClasses()}>
        <i key={NumberUtility.random(1, 10000)} className={getIconClasses()} />
      </div>
      <h1 key={NumberUtility.random(1, 10000)} id="search-bar-sass-statement">{sass.statement}</h1>
    </div>
  )
}

interface SearchResultProps {
  index: number;
  result: IUnsplashPhoto;
}

const SearchResult: React.FC<SearchResultProps> = (props: SearchResultProps) => {
  const [visible, setVisibleTo] = React.useState<boolean>(false),
        [loaded, setLoadedTo] = React.useState<boolean>(false),
        [size, setSizeTo] = React.useState<number>(0);
  
  const { result } = props;
  
  React.useEffect(() => {
    setSizeTo(NumberUtility.random(5, 10));
  }, []);
  
  React.useEffect(() => {
    if(visible) {
      const preview: HTMLImageElement = new Image();
      preview.src = result.urls.small;

      preview.onload = () => {
        setLoadedTo(true);
      };
    }
  }, [visible]);

  React.useEffect(() => {
    const ms: number = (props.index * 50) + NumberUtility.random(0, 50);
    
    const timeout: NodeJS.Timeout = setTimeout(() => {
      setVisibleTo(true);
    }, ms);
    
    return () => {
      clearTimeout(timeout);
    }
  }, []);
  
  const classes: string = classNames("search-result", { loaded, visible });
  
  const photoUrl: string = `https://unsplash.com/photos/${result.id}?utm_source=CodePen&utm_medium=referral`,
        creatorUrl: string = `${result.creator.link}?utm_source=CodePen&utm_medium=referral`;
  
  const backgroundImage: string = `url(${result.urls.small}), url(${result.urls.thumbnail})`,
        gridRowEnd: string = `span ${size}`;
  
  return (
    <div className={classes} style={{ gridRowEnd }}>
      <a className="search-result-background" href={photoUrl} style={{ backgroundColor: result.color, backgroundImage }} target="_blank" />
      <div className="search-result-info-wrapper">
        <div className="search-result-info">
          <a className="search-result-creator" href={creatorUrl} target="_blank">{result.creator.name}</a>
        </div>
      </div>
    </div>
  );
}

interface SearchResultsProps {
  results: IUnsplashPhoto[];
}

const SearchResults: React.FC<SearchResultsProps> = (props: SearchResultsProps) => {
  const getResults = (): JSX.Element[] => {
    return props.results.map((result: IUnsplashPhoto, index: number) => (
      <SearchResult key={result.id} index={index} result={result} />
    ));
  }

  const getYouTubeLinks = (): JSX.Element => {
    if(props.results.length > 0) {
      return (
        <YouTubeLinks />
      );
    }
  }

  return (
    <div id="search-results-wrapper">
    {getYouTubeLinks()} 
      <div id="search-results">
        {getResults()}
      </div>
    </div>
  );
}

const SearchBar: React.FC = () => {
  const { state, setInteractionTo, setStateTo } = React.useContext<IAppContext>(AppContext);
  
  const ref: React.MutableRefObject<HTMLInputElement> = React.useRef<HTMLInputElement>(null);
  
  const focused: boolean = state.interaction !== Interaction.Unknown && state.interaction !== Interaction.Leaving,
        querying: boolean = state.query !== "";
  
  const simulateSearch = (collectionID: UnsplashPhotoCollectionID): Promise<IUnsplashPhoto[]> => {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(UnsplashPhotoRepository.random(30, collectionID));
      }, 800);
    });
  }
  
  const handleOnSearch = async (): Promise<void> => {
    if(state.query.trim() === "") {
      return;
    } else if(state.query.trim() === state.previousQuery.trim()) {
      setInteractionTo(Interaction.Duplicate);
    } else if(state.status !== RequestStatus.Loading) {
      setStateTo({
        ...state,
        results: [],
        status: RequestStatus.Loading          
      });
      
      const collectionID: UnsplashPhotoCollectionID = UnsplashPhotoRepository.randomCollection(state.query),
            matches: boolean = state.query.trim().toLowerCase() === collectionID,
            interaction: Interaction = matches ? Interaction.CorrectQuery : Interaction.Initiated;
      
      const results: IUnsplashPhoto[] = await simulateSearch(collectionID);
      
      setStateTo({
        ...state,
        collectionID,
        interaction,
        previousQuery: state.query.trim(),
        results,
        searching: true,
        status: RequestStatus.Success
      });
    }
  }
  
  const handleOnBlur = (): void => {
    setInteractionTo(Interaction.Leaving);
  }
  
  const handleOnChange = (query: string): void => {
    setStateTo({
      ...state,
      interaction: Interaction.Typing,
      query
    })
  }
  
  const handleOnFocus = (): void => {    
    if(state.interaction === Interaction.Leaving) {
      setInteractionTo(Interaction.Returning);
    } else {
      setInteractionTo(Interaction.Initiated);
    }
  }
  
  const handleOnKeyDown = (e: any): void => {
    if(e.key === "Enter") {
      handleOnSearch();
    }
  }
  
  const getClicker = (): JSX.Element => {
    if(!focused && !state.searching) {
      const handleOnClick = (): void => {
        ref.current.focus(); 
      }

      return (
        <div id="search-bar-clicker" onClick={handleOnClick} />
      );
    }
  }
  
  const getResetButton = (): JSX.Element => {    
    if(state.searching) {
      const handleOnReset = (): void => {
        setStateTo(defaultAppState());
      }
      
      return (
        <button id="search-bar-reset-button" type="button" onClick={handleOnReset}>
          <i className="fa-regular fa-arrow-rotate-right" />
        </button>
      );
    }
  }
  
  return (
    <div id="search-bar-aligner" className={classNames({ focused, querying, searching: state.searching })}>
      <div id="search-bar-wrapper">
        <div id="search-bar">
          {getClicker()}
          <i id="search-bar-logo" className={Icon.Search} />
          <input 
            autoComplete="off"
            onBlur={handleOnBlur}
            onFocus={handleOnFocus}
            id="search-bar-input"
            placeholder="Search"
            ref={ref}
            type="text" 
            value={state.query}
            onChange={(e: any) => handleOnChange(e.target.value)}
            onKeyDown={handleOnKeyDown}
          />
          {getResetButton()}
        </div>
        <SearchBarSass />
      </div>
    </div>
  );
}

interface IAppState {
  background: IUnsplashPhoto;
  collectionID: UnsplashPhotoCollectionID;
  interaction: Interaction;
  previousQuery: string;
  query: string;
  results: IUnsplashPhoto[];
  searching: boolean;
  status: RequestStatus;
}

const defaultAppState = (): IAppState => ({
  background: UnsplashPhotoRepository.random(1, "animals"),  
  collectionID: null,
  interaction: Interaction.Unknown,
  previousQuery: "",
  query: "",
  results: [],
  searching: false,
  status: RequestStatus.Idle
});

interface IAppContext {
  state: IAppState;
  setInteractionTo: (interaction: Interaction) => void;
  setStateTo: (state: IAppState) => void;
}

const AppContext = React.createContext<IAppContext>(null);

const App: React.FC = () => {
  const [state, setStateTo] = React.useState<IAppState>(defaultAppState());
  
  /* -- Example search -- */
  React.useEffect(() => {
    const query: string = "Hit the reset button ➡️",
          collectionID: UnsplashPhotoCollectionID = UnsplashPhotoRepository.randomCollection();
    
    setStateTo({ ...state, query, status: RequestStatus.Loading });
    
    setTimeout(() => {      
      setStateTo({
        ...state,
        collectionID,
        interaction: Interaction.Initiated,
        query,
        previousQuery: query,
        results: UnsplashPhotoRepository.random(30, collectionID),
        searching: true,
        status: RequestStatus.Success
      });
    }, 500);
  }, []);
  /* -- ---------- -- */

  const setInteractionTo = (interaction: Interaction): void => {
    setStateTo({ ...state, interaction });
  }

  const getBackgroundStyles = (): React.CSSProperties => ({
    backgroundColor: state.background.color,
    backgroundImage: `url(${state.background.urls.regular}), url(${state.background.urls.small})`
  });
  
  const value: IAppContext = { 
    state, 
    setInteractionTo, 
    setStateTo
  }
  
  const memoizedSearchResults = React.useMemo(
    () => <SearchResults results={state.results} />, 
    [state.results]
  );

  return(
    <AppContext.Provider value={value}>
      <div id="app">
        <div id="app-background" className={classNames({ searching: state.searching })}>
          <div id="app-background-image" style={getBackgroundStyles()} />
          <div id="app-background-image-filter" />
        </div>
        <SearchBar />
        {memoizedSearchResults}
      </div>
    </AppContext.Provider>
  )
}

ReactDOM.render(<App/>, document.getElementById("root"));
</script>














</html>
